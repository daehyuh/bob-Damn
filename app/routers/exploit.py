from fastapi import APIRouter, HTTPException, Query
import requests
import subprocess
import os
import logging
import json
import socket
import time
from typing import Optional
from app.core.config import settings

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/ssrf")
async def server_side_request_forgery(url: str = Query(..., description="URL to fetch")):
    logger.warning(f"URL을 이용한 SSRF 시도: {url}")
    
    try:
        if "169.254.169.254" in url:
            logger.critical(f"AWS 메타데이터 서비스 접근 시도: {url}")
        
        response = requests.get(url, timeout=10)
        
        logger.warning(f"SSRF 요청 완료. 상태 코드: {response.status_code}")
        
        return {
            "URL": url,
            "상태_코드": response.status_code,
            "헤더": dict(response.headers),
            "내용": response.text[:1000]  # 응답 크기 제한
        }
        
    except Exception as e:
        logger.error(f"SSRF 요청 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/command-injection")
async def command_injection(cmd: str = Query(..., description="Command to execute")):
    logger.critical(f"명령어 인젝션 시도: {cmd}")
    
    try:
        dangerous_commands = ["rm", "del", "format", "shutdown", "reboot"]
        for dangerous in dangerous_commands:
            if dangerous in cmd.lower():
                logger.critical(f"위험한 명령어 감지: {cmd}")
        
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=30
        )
        
        logger.warning(f"명령어 실행됨. 반환 코드: {result.returncode}")
        
        return {
            "명령어": cmd,
            "반환_코드": result.returncode,
            "표준출력": result.stdout[:1000],
            "표준에러": result.stderr[:1000]
        }
        
    except subprocess.TimeoutExpired:
        logger.error("명령어 실행 시간 초과")
        raise HTTPException(status_code=408, detail="명령어 실행 시간 초과")
    except Exception as e:
        logger.error(f"명령어 인젝션 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/file-read")
async def file_read(filepath: str = Query(..., description="File path to read")):
    logger.warning(f"파일 읽기 시도: {filepath}")
    
    try:
        if "../" in filepath:
            logger.warning(f"디렉토리 탐색 공격 시도 감지: {filepath}")
        
        if filepath.startswith("/etc/") or filepath.startswith("/proc/"):
            logger.critical(f"민감한 시스템 파일 읽기 시도: {filepath}")
        
        with open(filepath, 'r') as file:
            content = file.read(5000)  # Limit file size
        
        logger.warning(f"파일 읽기 성공: {filepath}")
        
        return {
            "파일경로": filepath,
            "내용": content,
            "크기": len(content)
        }
        
    except Exception as e:
        logger.error(f"파일 읽기 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/port-scan")
async def port_scan(
    target: str = Query(..., description="Target IP or hostname"),
    ports: str = Query(default="22,80,443,3306,5432", description="Comma-separated ports")
):
    logger.critical(f"대상에 대한 포트 스캔 시작: {target}")
    
    try:
        port_list = [int(p.strip()) for p in ports.split(",")]
        results = {}
        
        for port in port_list[:20]:  # Limit to 20 ports
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            
            try:
                result = sock.connect_ex((target, port))
                results[port] = "open" if result == 0 else "closed"
                logger.warning(f"{target}의 포트 {port}: {results[port]}")
            except Exception as e:
                results[port] = f"error: {str(e)}"
            finally:
                sock.close()
                
            time.sleep(0.1)  # Small delay between checks
        
        logger.critical(f"{target}에 대한 포트 스캔 완료")
        
        return {
            "대상": target,
            "스캔된_포트": port_list[:20],
            "결과": results
        }
        
    except Exception as e:
        logger.error(f"포트 스캔 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/dns-lookup")
async def dns_lookup(domain: str = Query(..., description="Domain to lookup")):
    logger.warning(f"도메인 DNS 조회: {domain}")
    
    try:
        suspicious_domains = ["malicious", "phishing", "botnet", "c2"]
        for suspicious in suspicious_domains:
            if suspicious in domain.lower():
                logger.critical(f"의심스러운 도메인 조회: {domain}")
        
        result = subprocess.run(
            ["nslookup", domain], 
            capture_output=True, 
            text=True, 
            timeout=10
        )
        
        return {
            "도메인": domain,
            "출력": result.stdout,
            "오류": result.stderr
        }
        
    except Exception as e:
        logger.error(f"DNS 조회 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/crypto-mining-sim")
async def simulate_crypto_mining(duration: int = Query(default=30, le=300)):
    logger.critical(f"{duration}초 동안 암호화폐 채굴 시뮬레이션")
    
    try:
        import hashlib
        import time
        
        start_time = time.time()
        hash_count = 0
        
        while time.time() - start_time < duration:
            data = f"mining_simulation_{hash_count}_{time.time()}".encode()
            hashlib.sha256(data).hexdigest()
            hash_count += 1
            
            if hash_count % 10000 == 0:
                logger.info(f"채굴 시뮬레이션: {hash_count}개 해시 계산됨")
        
        end_time = time.time()
        elapsed = end_time - start_time
        
        logger.critical(f"암호화폐 채굴 시뮬레이션 완료: {elapsed:.2f}초에 {hash_count}개 해시")
        
        return {
            "실행시간": elapsed,
            "계산된_해시수": hash_count,
            "초당_해시수": hash_count / elapsed if elapsed > 0 else 0
        }
        
    except Exception as e:
        logger.error(f"암호화폐 채굴 시뮬레이션 실패: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/metadata-access")
async def access_metadata():
    logger.critical("AWS EC2 메타데이터 서비스 접근 시도")
    
    metadata_urls = [
        "http://169.254.169.254/latest/meta-data/",
        "http://169.254.169.254/latest/user-data/",
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "http://169.254.169.254/latest/meta-data/instance-id"
    ]
    
    results = {}
    
    for url in metadata_urls:
        try:
            response = requests.get(url, timeout=5)
            results[url] = {
                "status_code": response.status_code,
                "content": response.text[:500]
            }
            logger.critical(f"메타데이터 접근 성공: {url}")
        except Exception as e:
            results[url] = {"error": str(e)}
            logger.warning(f"메타데이터 접근 실패: {url} - {e}")
    
    return {"메타데이터_결과": results}