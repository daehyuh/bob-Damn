from fastapi import APIRouter, HTTPException, Query
import requests
import subprocess
import os
import logging
import json
import socket
import time
from typing import Optional
from app.core.config import settings

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/ssrf")
async def server_side_request_forgery(url: str = Query(..., description="URL to fetch")):
    logger.warning(f"SSRF attempt with URL: {url}")
    
    try:
        if "169.254.169.254" in url:
            logger.critical(f"Attempt to access AWS metadata service: {url}")
        
        response = requests.get(url, timeout=10)
        
        logger.warning(f"SSRF request completed. Status: {response.status_code}")
        
        return {
            "url": url,
            "status_code": response.status_code,
            "headers": dict(response.headers),
            "content": response.text[:1000]  # Limit response size
        }
        
    except Exception as e:
        logger.error(f"SSRF request failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/command-injection")
async def command_injection(cmd: str = Query(..., description="Command to execute")):
    logger.critical(f"Command injection attempt: {cmd}")
    
    try:
        dangerous_commands = ["rm", "del", "format", "shutdown", "reboot"]
        for dangerous in dangerous_commands:
            if dangerous in cmd.lower():
                logger.critical(f"Dangerous command detected: {cmd}")
        
        result = subprocess.run(
            cmd, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=30
        )
        
        logger.warning(f"Command executed. Return code: {result.returncode}")
        
        return {
            "command": cmd,
            "return_code": result.returncode,
            "stdout": result.stdout[:1000],
            "stderr": result.stderr[:1000]
        }
        
    except subprocess.TimeoutExpired:
        logger.error("Command execution timeout")
        raise HTTPException(status_code=408, detail="Command execution timeout")
    except Exception as e:
        logger.error(f"Command injection failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/file-read")
async def file_read(filepath: str = Query(..., description="File path to read")):
    logger.warning(f"File read attempt: {filepath}")
    
    try:
        if "../" in filepath:
            logger.warning(f"Directory traversal attempt detected: {filepath}")
        
        if filepath.startswith("/etc/") or filepath.startswith("/proc/"):
            logger.critical(f"Attempt to read sensitive system file: {filepath}")
        
        with open(filepath, 'r') as file:
            content = file.read(5000)  # Limit file size
        
        logger.warning(f"File successfully read: {filepath}")
        
        return {
            "filepath": filepath,
            "content": content,
            "size": len(content)
        }
        
    except Exception as e:
        logger.error(f"File read failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/port-scan")
async def port_scan(
    target: str = Query(..., description="Target IP or hostname"),
    ports: str = Query(default="22,80,443,3306,5432", description="Comma-separated ports")
):
    logger.critical(f"Port scan initiated against: {target}")
    
    try:
        port_list = [int(p.strip()) for p in ports.split(",")]
        results = {}
        
        for port in port_list[:20]:  # Limit to 20 ports
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            
            try:
                result = sock.connect_ex((target, port))
                results[port] = "open" if result == 0 else "closed"
                logger.warning(f"Port {port} on {target}: {results[port]}")
            except Exception as e:
                results[port] = f"error: {str(e)}"
            finally:
                sock.close()
                
            time.sleep(0.1)  # Small delay between checks
        
        logger.critical(f"Port scan completed against {target}")
        
        return {
            "target": target,
            "ports_scanned": port_list[:20],
            "results": results
        }
        
    except Exception as e:
        logger.error(f"Port scan failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/dns-lookup")
async def dns_lookup(domain: str = Query(..., description="Domain to lookup")):
    logger.warning(f"DNS lookup for domain: {domain}")
    
    try:
        suspicious_domains = ["malicious", "phishing", "botnet", "c2"]
        for suspicious in suspicious_domains:
            if suspicious in domain.lower():
                logger.critical(f"Suspicious domain lookup: {domain}")
        
        result = subprocess.run(
            ["nslookup", domain], 
            capture_output=True, 
            text=True, 
            timeout=10
        )
        
        return {
            "domain": domain,
            "output": result.stdout,
            "error": result.stderr
        }
        
    except Exception as e:
        logger.error(f"DNS lookup failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/crypto-mining-sim")
async def simulate_crypto_mining(duration: int = Query(default=30, le=300)):
    logger.critical(f"Simulating crypto mining for {duration} seconds")
    
    try:
        import hashlib
        import time
        
        start_time = time.time()
        hash_count = 0
        
        while time.time() - start_time < duration:
            data = f"mining_simulation_{hash_count}_{time.time()}".encode()
            hashlib.sha256(data).hexdigest()
            hash_count += 1
            
            if hash_count % 10000 == 0:
                logger.info(f"Mining simulation: {hash_count} hashes computed")
        
        end_time = time.time()
        elapsed = end_time - start_time
        
        logger.critical(f"Crypto mining simulation completed: {hash_count} hashes in {elapsed:.2f} seconds")
        
        return {
            "duration": elapsed,
            "hashes_computed": hash_count,
            "hashes_per_second": hash_count / elapsed if elapsed > 0 else 0
        }
        
    except Exception as e:
        logger.error(f"Crypto mining simulation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/metadata-access")
async def access_metadata():
    logger.critical("Attempting to access AWS EC2 metadata service")
    
    metadata_urls = [
        "http://169.254.169.254/latest/meta-data/",
        "http://169.254.169.254/latest/user-data/",
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "http://169.254.169.254/latest/meta-data/instance-id"
    ]
    
    results = {}
    
    for url in metadata_urls:
        try:
            response = requests.get(url, timeout=5)
            results[url] = {
                "status_code": response.status_code,
                "content": response.text[:500]
            }
            logger.critical(f"Metadata access successful: {url}")
        except Exception as e:
            results[url] = {"error": str(e)}
            logger.warning(f"Metadata access failed: {url} - {e}")
    
    return {"metadata_results": results}